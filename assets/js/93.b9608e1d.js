(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{409:function(t,s,a){"use strict";a.r(s);var e=a(27),v=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#usememo、usecallback用途"}},[t._v("useMemo、useCallback用途")])]),s("li",[s("a",{attrs:{href:"#常见误区"}},[t._v("常见误区")])]),s("li",[s("a",{attrs:{href:"#正确的使用场景"}},[t._v("正确的使用场景")])])])]),s("p"),t._v(" "),s("h1",{attrs:{id:"react之渲染优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react之渲染优化"}},[t._v("#")]),t._v(" React之渲染优化")]),t._v(" "),s("p",[t._v("React 的 useMemo 和 useCallback 这两个 Hook 主要用于记忆化（memoization），即在组件重新渲染时缓存某个值或函数，避免重复创建。但是在大多数情况下我们其实不需要它们，甚至过度使用会让应用变慢、代码更复杂。")]),t._v(" "),s("h2",{attrs:{id:"usememo、usecallback用途"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usememo、usecallback用途"}},[t._v("#")]),t._v(" useMemo、useCallback用途")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[s("code",[t._v("useMemo")]),t._v("：缓存计算结果或对象，防止在每次渲染时被重新创建。\n"),s("code",[t._v("useCallback")]),t._v("：缓存函数引用，防止在依赖不变的情况下生成新函数。")]),t._v(" "),s("p",[t._v("以上两个方法只在"),s("strong",[t._v("重新渲染")]),t._v("阶段有用，在"),s("strong",[t._v("初次渲染时")]),t._v("反而会拖慢性能")])]),t._v(" "),s("h2",{attrs:{id:"常见误区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见误区"}},[t._v("#")]),t._v(" 常见误区")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("1、为所有"),s("code",[t._v("props")]),t._v("加上"),s("code",[t._v("useMemo/useCallback")]),t._v(" "),s("ul",[s("li",[t._v("没有必要，除非该子组件被"),s("code",[t._v("React.memo")]),t._v("包裹，否则不会阻止重渲染。")])])]),t._v(" "),s("li",[t._v("2、认为"),s("code",[t._v("props")]),t._v("记忆化就能防止重复渲染；\n"),s("ul",[s("li",[t._v("实际上，只要父组件重新渲染，子组件仍会跟着渲染，除非用"),s("code",[t._v("React.memo")])])])]),t._v(" "),s("li",[t._v("3、误认为所有计算都昂贵；\n"),s("ul",[s("li",[t._v("普通操作（数组排序、对象创建）通常只需要几毫秒，不值得记忆化。除非你真的在计算大数的阶乘，否则不要对所有纯 "),s("code",[t._v("JavaScript")]),t._v(" 操作使用 "),s("code",[t._v("useMemo")])])])])])]),t._v(" "),s("h2",{attrs:{id:"正确的使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正确的使用场景"}},[t._v("#")]),t._v(" 正确的使用场景")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("仅在以下情况下使用")]),t._v(" "),s("ul",[s("li",[t._v("子组件被"),s("code",[t._v("React.memo")]),t._v("包裹，且传入的"),s("code",[t._v("props")]),t._v("都稳定不变：")]),t._v(" "),s("li",[t._v("某段计算确实非常昂贵（如大数据处理，复杂数学计算）;")]),t._v(" "),s("li",[t._v("需要维持函数、对象引用稳定性，避免触发无意义的依赖更新;")])]),t._v(" "),s("p",[t._v("对“原生” JavaScript 操作（即纯计算、对象/数组创建、过滤/排序等）不要包裹 "),s("code",[t._v("useMemo")]),t._v(" —— 与其浪费时间在它上面，不如专注于子组件更新；它们才是你的真正瓶颈。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);